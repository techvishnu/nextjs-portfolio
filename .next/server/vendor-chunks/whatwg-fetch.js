"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/whatwg-fetch";
exports.ids = ["vendor-chunks/whatwg-fetch"];
exports.modules = {

/***/ "(rsc)/./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMException: () => (/* binding */ DOMException),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n/* eslint-disable no-prototype-builtins */ var g = typeof globalThis !== \"undefined\" && globalThis || typeof self !== \"undefined\" && self || // eslint-disable-next-line no-undef\ntypeof global !== \"undefined\" && global || {};\nvar support = {\n    searchParams: \"URLSearchParams\" in g,\n    iterable: \"Symbol\" in g && \"iterator\" in Symbol,\n    blob: \"FileReader\" in g && \"Blob\" in g && function() {\n        try {\n            new Blob();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }(),\n    formData: \"FormData\" in g,\n    arrayBuffer: \"ArrayBuffer\" in g\n};\nfunction isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj);\n}\nif (support.arrayBuffer) {\n    var viewClasses = [\n        \"[object Int8Array]\",\n        \"[object Uint8Array]\",\n        \"[object Uint8ClampedArray]\",\n        \"[object Int16Array]\",\n        \"[object Uint16Array]\",\n        \"[object Int32Array]\",\n        \"[object Uint32Array]\",\n        \"[object Float32Array]\",\n        \"[object Float64Array]\"\n    ];\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n    };\n}\nfunction normalizeName(name) {\n    if (typeof name !== \"string\") {\n        name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === \"\") {\n        throw new TypeError('Invalid character in header field name: \"' + name + '\"');\n    }\n    return name.toLowerCase();\n}\nfunction normalizeValue(value) {\n    if (typeof value !== \"string\") {\n        value = String(value);\n    }\n    return value;\n}\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n    var iterator = {\n        next: function() {\n            var value = items.shift();\n            return {\n                done: value === undefined,\n                value: value\n            };\n        }\n    };\n    if (support.iterable) {\n        iterator[Symbol.iterator] = function() {\n            return iterator;\n        };\n    }\n    return iterator;\n}\nfunction Headers(headers) {\n    this.map = {};\n    if (headers instanceof Headers) {\n        headers.forEach(function(value, name) {\n            this.append(name, value);\n        }, this);\n    } else if (Array.isArray(headers)) {\n        headers.forEach(function(header) {\n            if (header.length != 2) {\n                throw new TypeError(\"Headers constructor: expected name/value pair to be length 2, found\" + header.length);\n            }\n            this.append(header[0], header[1]);\n        }, this);\n    } else if (headers) {\n        Object.getOwnPropertyNames(headers).forEach(function(name) {\n            this.append(name, headers[name]);\n        }, this);\n    }\n}\nHeaders.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + \", \" + value : value;\n};\nHeaders.prototype[\"delete\"] = function(name) {\n    delete this.map[normalizeName(name)];\n};\nHeaders.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null;\n};\nHeaders.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name));\n};\nHeaders.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n};\nHeaders.prototype.forEach = function(callback, thisArg) {\n    for(var name in this.map){\n        if (this.map.hasOwnProperty(name)) {\n            callback.call(thisArg, this.map[name], name, this);\n        }\n    }\n};\nHeaders.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n        items.push(name);\n    });\n    return iteratorFor(items);\n};\nHeaders.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n        items.push(value);\n    });\n    return iteratorFor(items);\n};\nHeaders.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n        items.push([\n            name,\n            value\n        ]);\n    });\n    return iteratorFor(items);\n};\nif (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n}\nfunction consumed(body) {\n    if (body._noBody) return;\n    if (body.bodyUsed) {\n        return Promise.reject(new TypeError(\"Already read\"));\n    }\n    body.bodyUsed = true;\n}\nfunction fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n        reader.onload = function() {\n            resolve(reader.result);\n        };\n        reader.onerror = function() {\n            reject(reader.error);\n        };\n    });\n}\nfunction readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise;\n}\nfunction readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);\n    var encoding = match ? match[1] : \"utf-8\";\n    reader.readAsText(blob, encoding);\n    return promise;\n}\nfunction readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n    for(var i = 0; i < view.length; i++){\n        chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join(\"\");\n}\nfunction bufferClone(buf) {\n    if (buf.slice) {\n        return buf.slice(0);\n    } else {\n        var view = new Uint8Array(buf.byteLength);\n        view.set(new Uint8Array(buf));\n        return view.buffer;\n    }\n}\nfunction Body() {\n    this.bodyUsed = false;\n    this._initBody = function(body) {\n        /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */ // eslint-disable-next-line no-self-assign\n        this.bodyUsed = this.bodyUsed;\n        this._bodyInit = body;\n        if (!body) {\n            this._noBody = true;\n            this._bodyText = \"\";\n        } else if (typeof body === \"string\") {\n            this._bodyText = body;\n        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n            this._bodyBlob = body;\n        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n            this._bodyFormData = body;\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n            this._bodyText = body.toString();\n        } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n            this._bodyArrayBuffer = bufferClone(body.buffer);\n            // IE 10-11 can't handle a DataView body.\n            this._bodyInit = new Blob([\n                this._bodyArrayBuffer\n            ]);\n        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n            this._bodyArrayBuffer = bufferClone(body);\n        } else {\n            this._bodyText = body = Object.prototype.toString.call(body);\n        }\n        if (!this.headers.get(\"content-type\")) {\n            if (typeof body === \"string\") {\n                this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n            } else if (this._bodyBlob && this._bodyBlob.type) {\n                this.headers.set(\"content-type\", this._bodyBlob.type);\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n            }\n        }\n    };\n    if (support.blob) {\n        this.blob = function() {\n            var rejected = consumed(this);\n            if (rejected) {\n                return rejected;\n            }\n            if (this._bodyBlob) {\n                return Promise.resolve(this._bodyBlob);\n            } else if (this._bodyArrayBuffer) {\n                return Promise.resolve(new Blob([\n                    this._bodyArrayBuffer\n                ]));\n            } else if (this._bodyFormData) {\n                throw new Error(\"could not read FormData body as blob\");\n            } else {\n                return Promise.resolve(new Blob([\n                    this._bodyText\n                ]));\n            }\n        };\n    }\n    this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n            var isConsumed = consumed(this);\n            if (isConsumed) {\n                return isConsumed;\n            } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n                return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));\n            } else {\n                return Promise.resolve(this._bodyArrayBuffer);\n            }\n        } else if (support.blob) {\n            return this.blob().then(readBlobAsArrayBuffer);\n        } else {\n            throw new Error(\"could not read as ArrayBuffer\");\n        }\n    };\n    this.text = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n            return rejected;\n        }\n        if (this._bodyBlob) {\n            return readBlobAsText(this._bodyBlob);\n        } else if (this._bodyArrayBuffer) {\n            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n        } else if (this._bodyFormData) {\n            throw new Error(\"could not read FormData body as text\");\n        } else {\n            return Promise.resolve(this._bodyText);\n        }\n    };\n    if (support.formData) {\n        this.formData = function() {\n            return this.text().then(decode);\n        };\n    }\n    this.json = function() {\n        return this.text().then(JSON.parse);\n    };\n    return this;\n}\n// HTTP methods whose capitalization should be normalized\nvar methods = [\n    \"CONNECT\",\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"PATCH\",\n    \"POST\",\n    \"PUT\",\n    \"TRACE\"\n];\nfunction normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method;\n}\nfunction Request(input, options) {\n    if (!(this instanceof Request)) {\n        throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n    }\n    options = options || {};\n    var body = options.body;\n    if (input instanceof Request) {\n        if (input.bodyUsed) {\n            throw new TypeError(\"Already read\");\n        }\n        this.url = input.url;\n        this.credentials = input.credentials;\n        if (!options.headers) {\n            this.headers = new Headers(input.headers);\n        }\n        this.method = input.method;\n        this.mode = input.mode;\n        this.signal = input.signal;\n        if (!body && input._bodyInit != null) {\n            body = input._bodyInit;\n            input.bodyUsed = true;\n        }\n    } else {\n        this.url = String(input);\n    }\n    this.credentials = options.credentials || this.credentials || \"same-origin\";\n    if (options.headers || !this.headers) {\n        this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || \"GET\");\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal || function() {\n        if (\"AbortController\" in g) {\n            var ctrl = new AbortController();\n            return ctrl.signal;\n        }\n    }();\n    this.referrer = null;\n    if ((this.method === \"GET\" || this.method === \"HEAD\") && body) {\n        throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n    }\n    this._initBody(body);\n    if (this.method === \"GET\" || this.method === \"HEAD\") {\n        if (options.cache === \"no-store\" || options.cache === \"no-cache\") {\n            // Search for a '_' parameter in the query string\n            var reParamSearch = /([?&])_=[^&]*/;\n            if (reParamSearch.test(this.url)) {\n                // If it already exists then set the value with the current time\n                this.url = this.url.replace(reParamSearch, \"$1_=\" + new Date().getTime());\n            } else {\n                // Otherwise add a new '_' parameter to the end with the current time\n                var reQueryString = /\\?/;\n                this.url += (reQueryString.test(this.url) ? \"&\" : \"?\") + \"_=\" + new Date().getTime();\n            }\n        }\n    }\n}\nRequest.prototype.clone = function() {\n    return new Request(this, {\n        body: this._bodyInit\n    });\n};\nfunction decode(body) {\n    var form = new FormData();\n    body.trim().split(\"&\").forEach(function(bytes) {\n        if (bytes) {\n            var split = bytes.split(\"=\");\n            var name = split.shift().replace(/\\+/g, \" \");\n            var value = split.join(\"=\").replace(/\\+/g, \" \");\n            form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n    });\n    return form;\n}\nfunction parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \" \");\n    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n    // https://github.com/github/fetch/issues/748\n    // https://github.com/zloirock/core-js/issues/751\n    preProcessedHeaders.split(\"\\r\").map(function(header) {\n        return header.indexOf(\"\\n\") === 0 ? header.substr(1, header.length) : header;\n    }).forEach(function(line) {\n        var parts = line.split(\":\");\n        var key = parts.shift().trim();\n        if (key) {\n            var value = parts.join(\":\").trim();\n            try {\n                headers.append(key, value);\n            } catch (error) {\n                console.warn(\"Response \" + error.message);\n            }\n        }\n    });\n    return headers;\n}\nBody.call(Request.prototype);\nfunction Response(bodyInit, options) {\n    if (!(this instanceof Response)) {\n        throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n    }\n    if (!options) {\n        options = {};\n    }\n    this.type = \"default\";\n    this.status = options.status === undefined ? 200 : options.status;\n    if (this.status < 200 || this.status > 599) {\n        throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\");\n    }\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText === undefined ? \"\" : \"\" + options.statusText;\n    this.headers = new Headers(options.headers);\n    this.url = options.url || \"\";\n    this._initBody(bodyInit);\n}\nBody.call(Response.prototype);\nResponse.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n        status: this.status,\n        statusText: this.statusText,\n        headers: new Headers(this.headers),\n        url: this.url\n    });\n};\nResponse.error = function() {\n    var response = new Response(null, {\n        status: 200,\n        statusText: \"\"\n    });\n    response.status = 0;\n    response.type = \"error\";\n    return response;\n};\nvar redirectStatuses = [\n    301,\n    302,\n    303,\n    307,\n    308\n];\nResponse.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n        throw new RangeError(\"Invalid status code\");\n    }\n    return new Response(null, {\n        status: status,\n        headers: {\n            location: url\n        }\n    });\n};\nvar DOMException = g.DOMException;\ntry {\n    new DOMException();\n} catch (err) {\n    DOMException = function(message, name) {\n        this.message = message;\n        this.name = name;\n        var error = Error(message);\n        this.stack = error.stack;\n    };\n    DOMException.prototype = Object.create(Error.prototype);\n    DOMException.prototype.constructor = DOMException;\n}\nfunction fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n        var request = new Request(input, init);\n        if (request.signal && request.signal.aborted) {\n            return reject(new DOMException(\"Aborted\", \"AbortError\"));\n        }\n        var xhr = new XMLHttpRequest();\n        function abortXhr() {\n            xhr.abort();\n        }\n        xhr.onload = function() {\n            var options = {\n                statusText: xhr.statusText,\n                headers: parseHeaders(xhr.getAllResponseHeaders() || \"\")\n            };\n            // This check if specifically for when a user fetches a file locally from the file system\n            // Only if the status is out of a normal range\n            if (request.url.startsWith(\"file://\") && (xhr.status < 200 || xhr.status > 599)) {\n                options.status = 200;\n            } else {\n                options.status = xhr.status;\n            }\n            options.url = \"responseURL\" in xhr ? xhr.responseURL : options.headers.get(\"X-Request-URL\");\n            var body = \"response\" in xhr ? xhr.response : xhr.responseText;\n            setTimeout(function() {\n                resolve(new Response(body, options));\n            }, 0);\n        };\n        xhr.onerror = function() {\n            setTimeout(function() {\n                reject(new TypeError(\"Network request failed\"));\n            }, 0);\n        };\n        xhr.ontimeout = function() {\n            setTimeout(function() {\n                reject(new TypeError(\"Network request timed out\"));\n            }, 0);\n        };\n        xhr.onabort = function() {\n            setTimeout(function() {\n                reject(new DOMException(\"Aborted\", \"AbortError\"));\n            }, 0);\n        };\n        function fixUrl(url) {\n            try {\n                return url === \"\" && g.location.href ? g.location.href : url;\n            } catch (e) {\n                return url;\n            }\n        }\n        xhr.open(request.method, fixUrl(request.url), true);\n        if (request.credentials === \"include\") {\n            xhr.withCredentials = true;\n        } else if (request.credentials === \"omit\") {\n            xhr.withCredentials = false;\n        }\n        if (\"responseType\" in xhr) {\n            if (support.blob) {\n                xhr.responseType = \"blob\";\n            } else if (support.arrayBuffer) {\n                xhr.responseType = \"arraybuffer\";\n            }\n        }\n        if (init && typeof init.headers === \"object\" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {\n            var names = [];\n            Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n                names.push(normalizeName(name));\n                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n            });\n            request.headers.forEach(function(value, name) {\n                if (names.indexOf(name) === -1) {\n                    xhr.setRequestHeader(name, value);\n                }\n            });\n        } else {\n            request.headers.forEach(function(value, name) {\n                xhr.setRequestHeader(name, value);\n            });\n        }\n        if (request.signal) {\n            request.signal.addEventListener(\"abort\", abortXhr);\n            xhr.onreadystatechange = function() {\n                // DONE (success or failure)\n                if (xhr.readyState === 4) {\n                    request.signal.removeEventListener(\"abort\", abortXhr);\n                }\n            };\n        }\n        xhr.send(typeof request._bodyInit === \"undefined\" ? null : request._bodyInit);\n    });\n}\nfetch.polyfill = true;\nif (!g.fetch) {\n    g.fetch = fetch;\n    g.Headers = Headers;\n    g.Request = Request;\n    g.Response = Response;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsd0NBQXdDLEdBQ3hDLElBQUlBLElBQ0YsT0FBUUMsZUFBZSxlQUFlQSxjQUNyQyxPQUFPQyxTQUFTLGVBQWVBLFFBQ2hDLG9DQUFvQztBQUNuQyxPQUFPQyxXQUFXLGVBQWVBLFVBQ2xDLENBQUM7QUFFSCxJQUFJQyxVQUFVO0lBQ1pDLGNBQWMscUJBQXFCTDtJQUNuQ00sVUFBVSxZQUFZTixLQUFLLGNBQWNPO0lBQ3pDQyxNQUNFLGdCQUFnQlIsS0FDaEIsVUFBVUEsS0FDVjtRQUNFLElBQUk7WUFDRixJQUFJUztZQUNKLE9BQU87UUFDVCxFQUFFLE9BQU9DLEdBQUc7WUFDVixPQUFPO1FBQ1Q7SUFDRjtJQUNGQyxVQUFVLGNBQWNYO0lBQ3hCWSxhQUFhLGlCQUFpQlo7QUFDaEM7QUFFQSxTQUFTYSxXQUFXQyxHQUFHO0lBQ3JCLE9BQU9BLE9BQU9DLFNBQVNDLFNBQVMsQ0FBQ0MsYUFBYSxDQUFDSDtBQUNqRDtBQUVBLElBQUlWLFFBQVFRLFdBQVcsRUFBRTtJQUN2QixJQUFJTSxjQUFjO1FBQ2hCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsSUFBSUMsb0JBQ0ZDLFlBQVlDLE1BQU0sSUFDbEIsU0FBU1AsR0FBRztRQUNWLE9BQU9BLE9BQU9JLFlBQVlJLE9BQU8sQ0FBQ0MsT0FBT1AsU0FBUyxDQUFDUSxRQUFRLENBQUNDLElBQUksQ0FBQ1gsUUFBUSxDQUFDO0lBQzVFO0FBQ0o7QUFFQSxTQUFTWSxjQUFjQyxJQUFJO0lBQ3pCLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzVCQSxPQUFPQyxPQUFPRDtJQUNoQjtJQUNBLElBQUksNkJBQTZCRSxJQUFJLENBQUNGLFNBQVNBLFNBQVMsSUFBSTtRQUMxRCxNQUFNLElBQUlHLFVBQVUsOENBQThDSCxPQUFPO0lBQzNFO0lBQ0EsT0FBT0EsS0FB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QUFFO1lBQ2xCMkMsUUFBUTNDLE1BQU0sQ0FBQytELGdCQUFnQixDQUFDLFNBQVNoQjtZQUV6Q0YsSUFBSW1CLGtCQUFrQixHQUFHO2dCQUN2Qiw0QkFBNEI7Z0JBQzVCLElBQUluQixJQUFJb0IsVUFBVSxLQUFLLEdBQUc7b0JBQ3hCdEIsUUFBUTNDLE1BQU0sQ0FBQ2tFLG1CQUFtQixDQUFDLFNBQVNuQjtnQkFDOUM7WUFDRjtRQUNGO1FBRUFGLElBQUlzQixJQUFJLENBQUMsT0FBT3hCLFFBQVF2RSxTQUFTLEtBQUssY0FBYyxPQUFPdUUsUUFBUXZFLFNBQVM7SUFDOUU7QUFDRjtBQUVBcUUsTUFBTTJCLFFBQVEsR0FBRztBQUVqQixJQUFJLENBQUNuTSxFQUFFd0ssS0FBSyxFQUFFO0lBQ1p4SyxFQUFFd0ssS0FBSyxHQUFHQTtJQUNWeEssRUFBRXlDLE9BQU8sR0FBR0E7SUFDWnpDLEVBQUV5SCxPQUFPLEdBQUdBO0lBQ1p6SCxFQUFFeUosUUFBUSxHQUFHQTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcz85Njg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGcgPVxuICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gIHt9XG5cbnZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGcsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBnICYmXG4gICAgJ0Jsb2InIGluIGcgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGcsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKVxuICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04J1xuICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZylcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgLypcbiAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkXG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ub0JvZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBhcyBBcnJheUJ1ZmZlcicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnQWJvcnRDb250cm9sbGVyJyBpbiBnKSB7XG4gICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICB9XG4gIH0oKSk7XG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxuXG4gIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovXG4gICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vXG4gICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAuc3BsaXQoJ1xccicpXG4gICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlICcgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc3BvbnNlJzogVGhlIHN0YXR1cyBwcm92aWRlZCAoMCkgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgWzIwMCwgNTk5XS5cIilcbiAgfVxuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2Uuc3RhdHVzID0gMFxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IGcuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICAvLyBUaGlzIGNoZWNrIGlmIHNwZWNpZmljYWxseSBmb3Igd2hlbiBhIHVzZXIgZmV0Y2hlcyBhIGZpbGUgbG9jYWxseSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICAgICAgLy8gT25seSBpZiB0aGUgc3RhdHVzIGlzIG91dCBvZiBhIG5vcm1hbCByYW5nZVxuICAgICAgaWYgKHJlcXVlc3QudXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSAmJiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID4gNTk5KSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IDIwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0JykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGcubG9jYXRpb24uaHJlZiA/IGcubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpXG5cbiAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXJcbiAgICAgICkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyB8fCAoZy5IZWFkZXJzICYmIGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIGcuSGVhZGVycykpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSlcbiAgICAgIH0pXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFnLmZldGNoKSB7XG4gIGcuZmV0Y2ggPSBmZXRjaFxuICBnLkhlYWRlcnMgPSBIZWFkZXJzXG4gIGcuUmVxdWVzdCA9IFJlcXVlc3RcbiAgZy5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iXSwibmFtZXMiOlsiZyIsImdsb2JhbFRoaXMiLCJzZWxmIiwiZ2xvYmFsIiwic3VwcG9ydCIsInNlYXJjaFBhcmFtcyIsIml0ZXJhYmxlIiwiU3ltYm9sIiwiYmxvYiIsIkJsb2IiLCJlIiwiZm9ybURhdGEiLCJhcnJheUJ1ZmZlciIsImlzRGF0YVZpZXciLCJvYmoiLCJEYXRhVmlldyIsInByb3RvdHlwZSIsImlzUHJvdG90eXBlT2YiLCJ2aWV3Q2xhc3NlcyIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpbmRleE9mIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwibm9ybWFsaXplTmFtZSIsIm5hbWUiLCJTdHJpbmciLCJ0ZXN0IiwiVHlwZUVycm9yIiwidG9Mb3dlckNhc2UiLCJub3JtYWxpemVWYWx1ZSIsInZhbHVlIiwiaXRlcmF0b3JGb3IiLCJpdGVtcyIsIml0ZXJhdG9yIiwibmV4dCIsInNoaWZ0IiwiZG9uZSIsInVuZGVmaW5lZCIsIkhlYWRlcnMiLCJoZWFkZXJzIiwibWFwIiwiZm9yRWFjaCIsImFwcGVuZCIsIkFycmF5IiwiaXNBcnJheSIsImhlYWRlciIsImxlbmd0aCIsImdldE93blByb3BlcnR5TmFtZXMiLCJvbGRWYWx1ZSIsImdldCIsImhhcyIsImhhc093blByb3BlcnR5Iiwic2V0IiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwia2V5cyIsInB1c2giLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiY29uc3VtZWQiLCJib2R5IiwiX25vQm9keSIsImJvZHlVc2VkIiwiUHJvbWlzZSIsInJlamVjdCIsImZpbGVSZWFkZXJSZWFkeSIsInJlYWRlciIsInJlc29sdmUiLCJvbmxvYWQiLCJyZXN1bHQiLCJvbmVycm9yIiwiZXJyb3IiLCJyZWFkQmxvYkFzQXJyYXlCdWZmZXIiLCJGaWxlUmVhZGVyIiwicHJvbWlzZSIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZEJsb2JBc1RleHQiLCJtYXRjaCIsImV4ZWMiLCJ0eXBlIiwiZW5jb2RpbmciLCJyZWFkQXNUZXh0IiwicmVhZEFycmF5QnVmZmVyQXNUZXh0IiwiYnVmIiwidmlldyIsIlVpbnQ4QXJyYXkiLCJjaGFycyIsImkiLCJmcm9tQ2hhckNvZGUiLCJqb2luIiwiYnVmZmVyQ2xvbmUiLCJzbGljZSIsImJ5dGVMZW5ndGgiLCJidWZmZXIiLCJCb2R5IiwiX2luaXRCb2R5IiwiX2JvZHlJbml0IiwiX2JvZHlUZXh0IiwiX2JvZHlCbG9iIiwiRm9ybURhdGEiLCJfYm9keUZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2JvZHlBcnJheUJ1ZmZlciIsInJlamVjdGVkIiwiRXJyb3IiLCJpc0NvbnN1bWVkIiwiYnl0ZU9mZnNldCIsInRoZW4iLCJ0ZXh0IiwiZGVjb2RlIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIm1ldGhvZHMiLCJub3JtYWxpemVNZXRob2QiLCJtZXRob2QiLCJ1cGNhc2VkIiwidG9VcHBlckNhc2UiLCJSZXF1ZXN0IiwiaW5wdXQiLCJvcHRpb25zIiwidXJsIiwiY3JlZGVudGlhbHMiLCJtb2RlIiwic2lnbmFsIiwiY3RybCIsIkFib3J0Q29udHJvbGxlciIsInJlZmVycmVyIiwiY2FjaGUiLCJyZVBhcmFtU2VhcmNoIiwicmVwbGFjZSIsIkRhdGUiLCJnZXRUaW1lIiwicmVRdWVyeVN0cmluZyIsImNsb25lIiwiZm9ybSIsInRyaW0iLCJzcGxpdCIsImJ5dGVzIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VIZWFkZXJzIiwicmF3SGVhZGVycyIsInByZVByb2Nlc3NlZEhlYWRlcnMiLCJzdWJzdHIiLCJsaW5lIiwicGFydHMiLCJrZXkiLCJjb25zb2xlIiwid2FybiIsIm1lc3NhZ2UiLCJSZXNwb25zZSIsImJvZHlJbml0Iiwic3RhdHVzIiwiUmFuZ2VFcnJvciIsIm9rIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlIiwicmVkaXJlY3RTdGF0dXNlcyIsInJlZGlyZWN0IiwibG9jYXRpb24iLCJET01FeGNlcHRpb24iLCJlcnIiLCJzdGFjayIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiZmV0Y2giLCJpbml0IiwicmVxdWVzdCIsImFib3J0ZWQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsImFib3J0WGhyIiwiYWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzdGFydHNXaXRoIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZVRleHQiLCJzZXRUaW1lb3V0Iiwib250aW1lb3V0Iiwib25hYm9ydCIsImZpeFVybCIsImhyZWYiLCJvcGVuIiwid2l0aENyZWRlbnRpYWxzIiwicmVzcG9uc2VUeXBlIiwibmFtZXMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2VuZCIsInBvbHlmaWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/whatwg-fetch/fetch.js\n");

/***/ })

};
;